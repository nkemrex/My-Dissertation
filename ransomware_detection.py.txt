import os
import hashlib
import pyinotify
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import IsolationForest
import smtplib

# Define the path to monitor
path_to_monitor = "/home/rex/ransomware_simulation"

# Define the E-Mail address to notify if ransomware is detected
notification_email = "Nkemjikakelechig@gmail.com"

# Define the maximum file size to check (in bytes)
max_file_size = 100000000

# Define the notification message to send if ransomware is detected
notification_message = f"Ransomware detected in {path_to_monitor}"


# Define the AI-driven honeypot-enabled active defense mechanism
class RansomwareDetector(pyinotify.ProcessEvent):
    def __init__(self):
        # Initialize the Isolation Forest algorithm with a contamination rate of 0.1 and 1000 trees
        self.iforest = IsolationForest(contamination=0.1, n_estimators=1000)
        self.file_features = None
        self.scaler = MinMaxScaler()

    def process_IN_CREATE(self, event):
        if os.path.isfile(event.pathname):
            if os.path.getsize(event.pathname) <= max_file_size:
                # Extract features from the file and add them to the file features array
                features = self.extract_features(event.pathname)
                if self.file_features is None:
                    self.file_features = np.array([features])
                else:
                    self.file_features = np.vstack([self.file_features, features])

                # Train the Isolation Forest algorithm with the updated file features array
                self.iforest.fit(self.file_features)

                # Check if the file is ransomware based on its score from the Isolation Forest algorithm
                score = self.iforest.score_samples(self.scaler.transform([features]))[0]
                if score < -0.5:
                    self.send_notification_email(notification_message)

    def process_IN_MODIFY(self, event):
        if os.path.isfile(event.pathname):
            if os.path.getsize(event.pathname) <= max_file_size:
                # Extract features from the file and update them in the file features array
                features = self.extract_features(event.pathname)
                if self.file_features is None:
                    self.file_features = np.array([features])
                else:
                    file_hashes = self.file_features[:, 0]
                    idx = np.where(file_hashes == features[0])[0]
                    if len(idx) > 0:
                        self.file_features[idx] = features
                    else:
                        self.file_features = np.vstack([self.file_features, features])

                # Train the Isolation Forest algorithm with the updated file features array
                self.iforest.fit(self.file_features)

                # Check if the file is ransomware based on its score from the Isolation Forest algorithm
                score = self.iforest.score_samples(self.scaler.transform([features]))[0]
                if score < -0.5:
                    self.send_notification_email(notification_message)

    def extract_features(self, file_path):
        # Calculate the SHA256 hash of the file
        file_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                file_hash.update(chunk)
        file_hash = int(file_hash.hexdigest(), 16)

        # Calculate the file size
        file_size = os.path.getsize(file_path)

        # Calculate the entropy of the file
        with open(file_path, "rb") as f:
            data = f.read()
            file_entropy = self.calculate_entropy(data)

        # Combine the features into a single array
        features = np.array([file_hash, file_size, file_entropy])

        return features

    def calculate_entropy(self, data):
        # Calculate the probability distribution of the data
        prob = [float(data.count(c)) / len(data) for c in dict.fromkeys(list(data))]

        # Calculate the entropy of the data
        entropy = -sum([p * np.log2(p) for p in prob])

        return entropy

    def send_notification_email(self, message):
        # Email configuration
        smtp_server = "smtp.gmail.com"
        smtp_port = 587
        sender_email = "Rexynkem@yandex.ru"
        sender_password = "lordrex1$"

        # Recipient email address
        recipient_email = notification_email

        # Create the email message
        subject = "Ransomware Detected"
        body = message
        email_message = f"Subject: {subject}\n\n{body}"

        # Send the email
        try:
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(sender_email, sender_password)
            server.sendmail(sender_email, recipient_email, email_message)
            server.quit()
            print("Notification email sent successfully!")
        except Exception as e:
            print(f"Failed to send notification email: {str(e)}")


def main():
    # Initialize the pyinotify watcher and event handler
    wm = pyinotify.WatchManager()
    handler = RansomwareDetector()

    # Add the path to monitor and set the event mask
    wm.add_watch(path_to_monitor, pyinotify.IN_CREATE | pyinotify.IN_MODIFY)

    # Initialize the notifier and start the event loop
    notifier = pyinotify.Notifier(wm, handler)
    notifier.loop()


if __name__ == '__main__':
    main()
